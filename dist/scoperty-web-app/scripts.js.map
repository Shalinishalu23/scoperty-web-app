{"version":3,"sources":["src/assets/javascript.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA","file":"scripts.js","sourcesContent":["function angular() {\r\n  class node {\r\n    constructor() {\r\n      this.key = 0;\r\n      this.count = 0;\r\n      this.left = null;\r\n      this.right = null;\r\n    }\r\n  }\r\n\r\n  // A utility function to create a new BST node\r\n  function newNode(item) {\r\n    var temp = new node();\r\n    temp.key = item;\r\n    temp.left = temp.right = null;\r\n    temp.count = 1;\r\n    return temp;\r\n  }\r\n\r\n  // A utility function to do inorder\r\n  // traversal of BST\r\n  function inorder(root) {\r\n    if (root != null) {\r\n      inorder(root.left);\r\n      document.write(root.key + \"(\" + root.count + \") \");\r\n      inorder(root.right);\r\n    }\r\n  }\r\n\r\n  /*\r\n* A utility function to insert a new\r\nnode with given key in BST\r\n*/\r\n  function insert(node, key) {\r\n    /* If the tree is empty, return a new node */\r\n    if (node == null) return newNode(key);\r\n\r\n    // If key already exists in BST,\r\n    // increment count and return\r\n    if (key == node.key) {\r\n      node.count++;\r\n      return node;\r\n    }\r\n\r\n    /* Otherwise, recur down the tree */\r\n    if (key < node.key) node.left = insert(node.left, key);\r\n    else node.right = insert(node.right, key);\r\n\r\n    /* return the (unchanged) node pointer */\r\n    return node;\r\n  }\r\n\r\n  /*\r\n* Given a non-empty binary search tree,\r\nreturn the node with minimum key value\r\n* found in that tree. Note that the\r\nentire tree does not need to be searched.\r\n*/\r\n  function minValueNode(node) {\r\n    var current = node;\r\n\r\n    /* loop down to find the leftmost leaf */\r\n    while (current.left != null) current = current.left;\r\n\r\n    return current;\r\n  }\r\n\r\n  /*\r\n* Given a binary search tree and a key,\r\nthis function deletes a given key and\r\n* returns root of modified tree\r\n*/\r\n  function deleteNode(root, key) {\r\n    // base case\r\n    if (root == null) return root;\r\n\r\n    // If the key to be deleted is smaller than the\r\n    // root's key, then it lies in left subtree\r\n    if (key < root.key) root.left = deleteNode(root.left, key);\r\n    // If the key to be deleted is greater than\r\n    // the root's key, then it lies in right subtree\r\n    else if (key > root.key) root.right = deleteNode(root.right, key);\r\n    // if key is same as root's key\r\n    else {\r\n      // If key is present more than once,\r\n      // simply decrement count and return\r\n      if (root.count > 1) {\r\n        root.count--;\r\n        return root;\r\n      }\r\n\r\n      // ElSE, delete the node\r\n\r\n      // node with only one child or no child\r\n      if (root.left == null) {\r\n        var temp = root.right;\r\n        root = null;\r\n        return temp;\r\n      } else if (root.right == null) {\r\n        var temp = root.left;\r\n        root = null;\r\n        return temp;\r\n      }\r\n\r\n      // node with two children: Get the inorder\r\n      // successor (smallest in the right subtree)\r\n      var temp = minValueNode(root.right);\r\n\r\n      // Copy the inorder successor's\r\n      // content to this node\r\n      root.key = temp.key;\r\n      root.count = temp.count;\r\n\r\n      // Delete the inorder successor\r\n      root.right = deleteNode(root.right, temp.key);\r\n    }\r\n    return root;\r\n  }\r\n\r\n  // Driver Code\r\n\r\n  /*\r\n    * Let us create following BST\r\n    12(3) / \\ 10(2) 20(1) / \\ 9(1) 11(1)\r\n    */\r\n  var root = null;\r\n  root = insert(root, \"she\");\r\n  root = insert(root, \"had\");\r\n  root = insert(root, \"had\");\r\n  root = insert(root, \"to\");\r\n  root = insert(root, \"address\");\r\n  root = insert(root, \"Problems\");\r\n\r\n  document.write(\"Inorder traversal of \" + \"the given tree \" + \"<br/>\");\r\n  inorder(root);\r\n\r\n  // document.write(\"<br/>Delete 20<br/>\");\r\n  // root = deleteNode(root, 20);\r\n  // document.write(\"Inorder traversal of \"\r\n  // + \"the modified tree <br/>\");\r\n  // inorder(root);\r\n\r\n  // document.write(\"<br/>Delete 12<br/>\");\r\n  // root = deleteNode(root, 12);\r\n  // document.write(\"Inorder traversal of \"\r\n  // + \"the modified tree <br/>\");\r\n  // inorder(root);\r\n\r\n  // document.write(\"<br/>Delete 9<br/>\");\r\n  // root = deleteNode(root, 9);\r\n  // document.write(\"Inorder traversal of \"\r\n  // + \"the modified tree <br/>\");\r\n  // inorder(root);\r\n}\r\n\r\nfunction javascripts() {\r\n  function averageZeroes(a) {\r\n    console.log(\"a\", a);\r\n    const rows = a.length;\r\n    const cols = a[0].length;\r\n    let b = [...Array(rows)].map((e) => Array(cols));\r\n    for (let r = 0; r < rows; r++) {\r\n      for (let c = 0; c < cols; c++) {\r\n        let v = a[r][c];\r\n        if (v == 0) {\r\n          let n = 0;\r\n          if (r > 0) {\r\n            n++;\r\n            v += a[r - 1][c];\r\n          }\r\n          if (r < rows - 1) {\r\n            n++;\r\n            v += a[r + 1][c];\r\n          }\r\n          if (c > 0) {\r\n            n++;\r\n            v += a[r][c - 1];\r\n          }\r\n          if (c < cols - 1) {\r\n            n++;\r\n            v += a[r][c + 1];\r\n          }\r\n          b[r][c] = v / n;\r\n        } else {\r\n          b[r][c] = a[r][c];\r\n        }\r\n      }\r\n    }\r\n    return b;\r\n  }\r\n\r\n  function test(a) {\r\n    const p = (m) => JSON.stringify(m).replaceAll(\"],[\", \"],\\n [\");\r\n    // console.log(p(a));\r\n    // console.log(p(averageZeroes(a)));\r\n    document.write(\"Input\" + \"CSV <br/>\");\r\n    document.write(p(a));\r\n    document.write(\"<br/>Output\" + \"CSV <br/>\");\r\n    document.write(p(averageZeroes(a)));\r\n  }\r\n\r\n  test([\r\n    [1, 2, 3],\r\n    [4, 8, 1],\r\n    [0, 1, 9],\r\n  ]);\r\n\r\n}\r\n"],"sourceRoot":"webpack:///"}